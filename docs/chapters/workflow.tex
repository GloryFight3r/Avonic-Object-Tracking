\section{Values and teamwork approach}
Our team has very specific values which we always aim to follow no matter the circumstances. This is how we ensure mutual trust and good understanding in the team.

The most important values we appreciate are hard work and authority. It goes without saying that we value hard work since we all aim to complete our project in the best possible way.
Authority is important to us because we should always respect Avonic and the university staff since they are the people who evaluate our work.
Another crucial value in our team is humor. It is always better when working becomes a pleasure and not a boresome duty.
\section{Workflow practices}
\subsection{Approaches}
To ensure a good workflow we decided to use Agile and more specifically -- Scrum.
Scrum gives teams the ability to cope with dynamic priorities and requirements by introducing sprint planning, retrospectives, and reviews.
This way of planning helps to organize collaborative work faster and more precisely.

As we had regular sprint planning session, planning poker practice fitted well with them.
However, this did not prove to work well immediately, as our overall vision of the issues seemed to be not accurate in the beginning.
Our improved became better in later stages of the project.

We also decided to employ TDD (test-driven development) as it has been shown to reduce number of bugs in the code.
It is also useful to write simple yet reliable code, and motivates a developer to be more conscious of the design decisions and edge cases.

\subsection{Requirements for new functionality}
In order to accept a new functionality we came up with three requirements:
\begin{enumerate}
	\item Has to have a test coverage of at least 80\%
	\item Has to have a clear description of the functionality
	\item Must not break any other functionality
\end{enumerate}

\subsection{Definition of done}
At the start of our project, we decided that the minimal viable product would be
one that has all the must-have requirements. The should-haves would be good to aim
for and the could-haves would be a bonus if they were fulfilled. For individual requirements
we also defined a definition of done in Gitlab so it would be clear when one was
completed. We only accepted functionality after this definition of done was satisfied.

\subsection{Additional tools}
\begin{itemize}
	\item \verb|pylint| for styling purposes
	\item \verb|pytest| for basic testing, \verb|pytest-cov| to calculate coverage
	\item \verb|mutmut| for mutation testing
	\item \verb|git| for version control using GitLab as the server
	\item CI (continuous integration) for quality assurance - runs on GitLab after each change
\end{itemize}

\subsection{Communication}
We make sure all work is done on time and in an upstanding way by meeting every day. This happens either on campus, in Avonic's office, or on Discord as a backup. We discuss our progress and help each other. If any problem arises we brainstorm and come up with solutions together.
Mattermost serves as a communication channel with our TA.
WhatsApp is our backup if everything else fails.

\section{Collaboration with Avonic}
Avonic was open to collaboration and in this section, we give some insights into how it went:

Every week we met with Mr. Kahawati to discuss the progress we are had since our last meeting.
During those meetings, we would discuss feedback on implemented features and their possible extensions.

As discussed in \hyperref[sec:possible-pitfalls]{possible pitfalls}. we could work in the office only a limited amount of time. Avonic gave us a camera and set up VPN for us, so we could continue work on project even when were not in the office.

In the beginning of the project, we experienced some problems with time outs of the camera connection over the network, but people in Avonic helped us figure out that it was caused by network settings and not us.

\section{Testing}
In this section we elaborate more on our testing experience and process throughout the development process.
As mentioned earlier we encouraged TDD in our process, but it was not enforced, as it is a personal preference.
This approach once more proved to be a very good practice because we managed to find many bugs and unexpected behavior early in development without breaking the functionality of our project.

One of our non-functional requirements was reaching at least 80\% test coverage of the code. 
We kept this number up throughout the whole development process.
During the midterm we were exactly at 80\% coverage with the vision that we would increase that number by the end of the project.
We indeed met that goal by reaching 92\% total coverage.

In order to make sure the quality of the tests we used mutation testing tool \verb|mutmut|.  
During this process we managed to locate bugs throughout the code as well as improve the tests themselves. 
Overall we made sure all our tests cover and capture all aspects of the functionality we have. 
Running this tool, however, posed a difficulty as our system tests take quite a lot of time to run because of the multithreaded nature of the project. 
That led to one run of \verb|mutmut| taking a couple of hours which meant we could not do it that often. 
At the midterm our mutation score was 56\% and we focused on improving that until the end of the project and reached 62\% in the end.

\section{Challenges}
In this section, we discuss the challenges we faced as a group and how we solved them.
\subsection{WebUI design with multiple tabs}
From the beginning of the project, the user interface was growing on a single page.
As the size of the application grew, a new vision for the UIâ€™s pages developed among a part of the team.

The changes introduced a multiple-tab design instead - each section would have own page.
You would need to switch to a different tab via the menu at the top of the page, to go to a different section.

When a team member presented their changes in the UI design before merging, opinions were divided, as it was not discussed prior to implementation.
Justification of both sides was centered around the comfort of using the WebUI - one part thought the previous solution was cluttered, while the other considered the new version to require more effort to use.

All of the steps from the Code of conduct were taken to reach a consensus, but the group was still divided after 2 rounds of discussions.
As we could not reach the decision ourselves, we have decided to ask Mr. Kahawati.
As described in that meeting, the UI is going to be used by technicians, so having everything on the same page is more practical for them, but it can also be used by people with little knowledge about cameras and a big menu can overwhelm them.

Therefore, the decision was to combine both designs. By default, a user is presented with a page with the whole functionality, but if they want to isolate certain aspects of it, they can click on a respective tab at the top of the page.
\textbf{THERE WILL BE AN IMAGE OF THE FINAL UI VERSION}

\subsection{Breaking production server}\label{subsection:breaking-production-server}
As discussed in subsection about the \hyperref[subsection:solution_webui]{WebUI}, we decided to use uWSGI for production mode.
When more features that relied on threads were added, some of them started using mutable variables, in a way that change of it in one of threads, would affect another one.
But, as we found out, it does not work when the server is run with uWSGI.
This lead to a lot of problems, as variables are not shared between processes.

We had not noticed it after a few merge requests that were rapidly merged because of the deadline.
We could not conduct a good quality assurance process and testing, which led to the fact that multiple features, like footage and information updates, stopped working.
As we did not have enough knowledge back in time, it took us a whole day of debugging to identify and fix the problem.

Since then, the quality assurance procedure was strengthened, to make sure that features work both in production and development modes.
